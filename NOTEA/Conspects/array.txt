{"Date":"2023-10-12T09:18:07.1108095+03:00","ConspectSemester":0,"Name":"array","ConspectText":"-- Hoogle documentation, generated by Haddock\r\n-- See Hoogle, http://www.haskell.org/hoogle/\r\n\r\n\r\n-- | Mutable and immutable arrays\r\n--   \r\n--   In addition to providing the <a>Data.Array</a> module <a>as specified\r\n--   in the Haskell 2010 Language Report</a>, this package also defines the\r\n--   classes <a>IArray</a> of immutable arrays and <a>MArray</a> of arrays\r\n--   mutable within appropriate monads, as well as some instances of these\r\n--   classes.\r\n@package array\r\n@version 0.5.4.0\r\n\r\n\r\n-- | Basic non-strict arrays.\r\n--   \r\n--   <i>Note:</i> The <a>Data.Array.IArray</a> module provides a more\r\n--   general interface to immutable arrays: it defines operations with the\r\n--   same names as those defined below, but with more general types, and\r\n--   also defines <a>Array</a> instances of the relevant classes. To use\r\n--   that more general interface, import <a>Data.Array.IArray</a> but not\r\n--   <a>Data.Array</a>.\r\nmodule Data.Array\r\n\r\n-- | The type of immutable non-strict (boxed) arrays with indices in\r\n--   <tt>i</tt> and elements in <tt>e</tt>.\r\ndata Array i e\r\n\r\n-- | Construct an array with the specified bounds and containing values for\r\n--   given indices within these bounds.\r\n--   \r\n--   The array is undefined (i.e. bottom) if any index in the list is out\r\n--   of bounds. The Haskell 2010 Report further specifies that if any two\r\n--   associations in the list have the same index, the value at that index\r\n--   is undefined (i.e. bottom). However in GHC's implementation, the value\r\n--   at such an index is the value part of the last association with that\r\n--   index in the list.\r\n--   \r\n--   Because the indices must be checked for these errors, <a>array</a> is\r\n--   strict in the bounds argument and in the indices of the association\r\n--   list, but non-strict in the values. Thus, recurrences such as the\r\n--   following are possible:\r\n--   \r\n--   <pre>\r\n--   a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i &lt;- [2..100]])\r\n--   </pre>\r\n--   \r\n--   Not every index within the bounds of the array need appear in the\r\n--   association list, but the values associated with indices that do not\r\n--   appear will be undefined (i.e. bottom).\r\n--   \r\n--   If, in any dimension, the lower bound is greater than the upper bound,\r\n--   then the array is legal, but empty. Indexing an empty array always\r\n--   gives an array-bounds error, but <a>bounds</a> still yields the bounds\r\n--   with which the array was constructed.\r\narray :: Ix i => (i, i) -> [(i, e)] -> Array i e\r\n\r\n-- | Construct an array from a pair of bounds and a list of values in index\r\n--   order.\r\nlistArray :: Ix i => (i, i) -> [e] -> Array i e\r\n\r\n-- | The <a>accumArray</a> function deals with repeated indices in the\r\n--   association list using an <i>accumulating function</i> which combines\r\n--   the values of associations with the same index.\r\n--   \r\n--   For example, given a list of values of some index type, <tt>hist</tt>\r\n--   produces a histogram of the number of occurrences of each index within\r\n--   a specified range:\r\n--   \r\n--   <pre>\r\n--   hist :: (Ix a, Num b) =&gt; (a,a) -&gt; [a] -&gt; Array a b\r\n--   hist bnds is = accumArray (+) 0 bnds [(i, 1) | i&lt;-is, inRange bnds i]\r\n--   </pre>\r\n--   \r\n--   <tt>accumArray</tt> is strict in each result of applying the\r\n--   accumulating function, although it is lazy in the initial value. Thus,\r\n--   unlike arrays built with <a>array</a>, accumulated arrays should not\r\n--   in general be recursive.\r\naccumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e\r\n\r\n-- | The value at the given index in an array.\r\n(!) :: Ix i => Array i e -> i -> e\r\ninfixl 9 !\r\n\r\n-- | The bounds with which an array was constructed.\r\nbounds :: Array i e -> (i, i)\r\n\r\n-- | The list of indices of an array in ascending order.\r\nindices :: Ix i => Array i e -> [i]\r\n\r\n-- | The list of elements of an array in index order.\r\nelems :: Array i e -> [e]\r\n\r\n-- | The list of associations of an array in index order.\r\nassocs :: Ix i => Array i e -> [(i, e)]\r\n\r\n-- | Constructs an array identical to the first argument except that it has\r\n--   been updated by the associations in the right argument. For example,\r\n--   if <tt>m</tt> is a 1-origin, <tt>n</tt> by <tt>n</tt> matrix, then\r\n--   \r\n--   <pre>\r\n--   m//[((i,i), 0) | i &lt;- [1..n]]\r\n--   </pre>\r\n--   \r\n--   is the same matrix, except with the diagonal zeroed.\r\n--   \r\n--   Repeated indices in the association list are handled as for\r\n--   <a>array</a>: Haskell 2010 specifies that the resulting array is\r\n--   undefined (i.e. bottom), but GHC's implementation uses the last\r\n--   association for each index.\r\n(//) :: Ix i => Array i e -> [(i, e)] -> Array i e\r\ninfixl 9 //\r\n\r\n-- | <tt><a>accum</a> f</tt> takes an array and an association list and\r\n--   accumulates pairs from the list into the array with the accumulating\r\n--   function <tt>f</tt>. Thus <a>accumArray</a> can be defined using\r\n--   <a>accum</a>:\r\n--   \r\n--   <pre>\r\n--   accumArray f z b = accum f (array b [(i, z) | i &lt;- range b])\r\n--   </pre>\r\n--   \r\n--   <tt>accum</tt> is strict in all the results of applying the\r\n--   accumulation. However, it is lazy in the initial values of the array.\r\naccum :: Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e\r\n\r\n-- | <a>ixmap</a> allows for transformations on array indices. It may be\r\n--   thought of as providing function composition on the right with the\r\n--   mapping that the original array embodies.\r\n--   \r\n--   A similar transformation of array values may be achieved using\r\n--   <a>fmap</a> from the <a>Array</a> instance of the <a>Functor</a>\r\n--   class.\r\nixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e\r\n\r\n\r\n-- | Immutable arrays, with an overloaded interface. For array types which\r\n--   can be used with this interface, see the <a>Array</a> type exported by\r\n--   this module and the <a>Data.Array.Unboxed</a> module. Other packages,\r\n--   such as diffarray, also provide arrays using this interface.\r\nmodule Data.Array.IArray\r\n\r\n-- | Class of immutable array types.\r\n--   \r\n--   An array type has the form <tt>(a i e)</tt> where <tt>a</tt> is the\r\n--   array type constructor (kind <tt>* -&gt; * -&gt; *</tt>), <tt>i</tt>\r\n--   is the index type (a member of the class <a>Ix</a>), and <tt>e</tt> is\r\n--   the element type. The <tt>IArray</tt> class is parameterised over both\r\n--   <tt>a</tt> and <tt>e</tt>, so that instances specialised to certain\r\n--   element types can be defined.\r\nclass IArray a e\r\n\r\n-- | The type of immutable non-strict (boxed) arrays with indices in\r\n--   <tt>i</tt> and elements in <tt>e</tt>.\r\ndata Array i e\r\n\r\n-- | Constructs an immutable array from a pair of bounds and a list of\r\n--   initial associations.\r\n--   \r\n--   The bounds are specified as a pair of the lowest and highest bounds in\r\n--   the array respectively. For example, a one-origin vector of length 10\r\n--   has bounds (1,10), and a one-origin 10 by 10 matrix has bounds\r\n--   ((1,1),(10,10)).\r\n--   \r\n--   An association is a pair of the form <tt>(i,x)</tt>, which defines the\r\n--   value of the array at index <tt>i</tt> to be <tt>x</tt>. The array is\r\n--   undefined if any index in the list is out of bounds. If any two\r\n--   associations in the list have the same index, the value at that index\r\n--   is implementation-dependent. (In GHC, the last value specified for\r\n--   that index is used. Other implementations will also do this for\r\n--   unboxed arrays, but Haskell 98 requires that for <tt>Array</tt> the\r\n--   value at such indices is bottom.)\r\n--   \r\n--   Because the indices must be checked for these errors, <a>array</a> is\r\n--   strict in the bounds argument and in the indices of the association\r\n--   list. Whether <tt>array</tt> is strict or non-strict in the elements\r\n--   depends on the array type: <a>Array</a> is a non-strict array type,\r\n--   but all of the <a>UArray</a> arrays are strict. Thus in a non-strict\r\n--   array, recurrences such as the following are possible:\r\n--   \r\n--   <pre>\r\n--   a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i \\&lt;- [2..100]])\r\n--   </pre>\r\n--   \r\n--   Not every index within the bounds of the array need appear in the\r\n--   association list, but the values associated with indices that do not\r\n--   appear will be undefined.\r\n--   \r\n--   If, in any dimension, the lower bound is greater than the upper bound,\r\n--   then the array is legal, but empty. Indexing an empty array always\r\n--   gives an array-bounds error, but <a>bounds</a> still yields the bounds\r\n--   with which the array was constructed.\r\narray :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e\r\n\r\n-- | Constructs an immutable array from a list of initial elements. The\r\n--   list gives the elements of the array in ascending order beginning with\r\n--   the lowest index.\r\nlistArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e\r\n\r\n-- | Constructs an immutable array from a list of associations. Unlike\r\n--   <a>array</a>, the same index is allowed to occur multiple times in the\r\n--   list of associations; an <i>accumulating function</i> is used to\r\n--   combine the values of elements with the same index.\r\n--   \r\n--   For example, given a list of values of some index type, hist produces\r\n--   a histogram of the number of occurrences of each index within a\r\n--   specified range:\r\n--   \r\n--   <pre>\r\n--   hist :: (Ix a, Num b) =&gt; (a,a) -&gt; [a] -&gt; Array a b\r\n--   hist bnds is = accumArray (+) 0 bnds [(i, 1) | i\\&lt;-is, inRange bnds i]\r\n--   </pre>\r\naccumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e\r\n\r\n-- | Returns the element of an immutable array at the specified index.\r\n(!) :: (IArray a e, Ix i) => a i e -> i -> e\r\n\r\n-- | Extracts the bounds of an immutable array\r\nbounds :: (IArray a e, Ix i) => a i e -> (i, i)\r\n\r\n-- | Returns a list of all the valid indices in an array.\r\nindices :: (IArray a e, Ix i) => a i e -> [i]\r\n\r\n-- | Returns a list of all the elements of an array, in the same order as\r\n--   their indices.\r\nelems :: (IArray a e, Ix i) => a i e -> [e]\r\n\r\n-- | Returns the contents of an array as a list of associations.\r\nassocs :: (IArray a e, Ix i) => a i e -> [(i, e)]\r\n\r\n-- | Takes an array and a list of pairs and returns an array identical to\r\n--   the left argument except that it has been updated by the associations\r\n--   in the right argument. For example, if m is a 1-origin, n by n matrix,\r\n--   then <tt>m//[((i,i), 0) | i &lt;- [1..n]]</tt> is the same matrix,\r\n--   except with the diagonal zeroed.\r\n--   \r\n--   As with the <a>array</a> function, if any two associations in the list\r\n--   have the same index, the value at that index is\r\n--   implementation-dependent. (In GHC, the last value specified for that\r\n--   index is used. Other implementations will also do this for unboxed\r\n--   arrays, but Haskell 98 requires that for <tt>Array</tt> the value at\r\n--   such indices is bottom.)\r\n--   \r\n--   For most array types, this operation is O(<i>n</i>) where <i>n</i> is\r\n--   the size of the array. However, the diffarray package provides an\r\n--   array type for which this operation has complexity linear in the\r\n--   number of updates.\r\n(//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e\r\n\r\n-- | <tt>accum f</tt> takes an array and an association list and\r\n--   accumulates pairs from the list into the array with the accumulating\r\n--   function <tt>f</tt>. Thus <a>accumArray</a> can be defined using\r\n--   <a>accum</a>:\r\n--   \r\n--   <pre>\r\n--   accumArray f z b = accum f (array b [(i, z) | i \\&lt;- range b])\r\n--   </pre>\r\naccum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e\r\n\r\n-- | Returns a new array derived from the original array by applying a\r\n--   function to each of the elements.\r\namap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e\r\n\r\n-- | Returns a new array derived from the original array by applying a\r\n--   function to each of the indices.\r\nixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e\r\n\r\n\r\n-- | An overloaded interface to mutable arrays. For array types which can\r\n--   be used with this interface, see <a>Data.Array.IO</a>,\r\n--   <a>Data.Array.ST</a>, and <a>Data.Array.Storable</a>.\r\nmodule Data.Array.MArray\r\n\r\n-- | Class of mutable array types.\r\n--   \r\n--   An array type has the form <tt>(a i e)</tt> where <tt>a</tt> is the\r\n--   array type constructor (kind <tt>* -&gt; * -&gt; *</tt>), <tt>i</tt>\r\n--   is the index type (a member of the class <a>Ix</a>), and <tt>e</tt> is\r\n--   the element type.\r\n--   \r\n--   The <tt>MArray</tt> class is parameterised over both <tt>a</tt> and\r\n--   <tt>e</tt> (so that instances specialised to certain element types can\r\n--   be defined, in the same way as for <a>IArray</a>), and also over the\r\n--   type of the monad, <tt>m</tt>, in which the mutable array will be\r\n--   manipulated.\r\nclass (Monad m) => MArray a e m\r\n\r\n-- | Builds a new array, with every element initialised to the supplied\r\n--   value.\r\nnewArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)\r\n\r\n-- | Builds a new array, with every element initialised to an undefined\r\n--   value. In a monadic context in which operations must be deterministic\r\n--   (e.g. the ST monad), the array elements are initialised to a fixed but\r\n--   undefined value, such as zero.\r\nnewArray_ :: (MArray a e m, Ix i) => (i, i) -> m (a i e)\r\n\r\n-- | Constructs a mutable array from a list of initial elements. The list\r\n--   gives the elements of the array in ascending order beginning with the\r\n--   lowest index.\r\nnewListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)\r\n\r\n-- | Read an element from a mutable array\r\nreadArray :: (MArray a e m, Ix i) => a i e -> i -> m e\r\n\r\n-- | Write an element in a mutable array\r\nwriteArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()\r\n\r\n-- | Constructs a new array derived from the original array by applying a\r\n--   function to each of the elements.\r\nmapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)\r\n\r\n-- | Constructs a new array derived from the original array by applying a\r\n--   function to each of the indices.\r\nmapIndices :: (MArray a e m, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> m (a i e)\r\n\r\n-- | Returns the bounds of the array\r\ngetBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)\r\n\r\n-- | Return a list of all the elements of a mutable array\r\ngetElems :: (MArray a e m, Ix i) => a i e -> m [e]\r\n\r\n-- | Return a list of all the associations of a mutable array, in index\r\n--   order.\r\ngetAssocs :: (MArray a e m, Ix i) => a i e -> m [(i, e)]\r\n\r\n-- | Converts a mutable array (any instance of <a>MArray</a>) to an\r\n--   immutable array (any instance of <a>IArray</a>) by taking a complete\r\n--   copy of it.\r\nfreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)\r\n\r\n-- | Converts an immutable array (any instance of <a>IArray</a>) into a\r\n--   mutable array (any instance of <a>MArray</a>) by taking a complete\r\n--   copy of it.\r\nthaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)\r\n\r\n\r\n-- | Mutable boxed and unboxed arrays in the IO monad.\r\nmodule Data.Array.IO\r\n\r\n-- | An <a>IOArray</a> is a mutable, boxed, non-strict array in the\r\n--   <a>IO</a> monad. The type arguments are as follows:\r\n--   \r\n--   <ul>\r\n--   <li><tt>i</tt>: the index type of the array (should be an instance of\r\n--   <a>Ix</a>)</li>\r\n--   <li><tt>e</tt>: the element type of the array.</li>\r\n--   </ul>\r\ndata IOArray i e\r\n\r\n-- | Mutable, unboxed, strict arrays in the <a>IO</a> monad. The type\r\n--   arguments are as follows:\r\n--   \r\n--   <ul>\r\n--   <li><tt>i</tt>: the index type of the array (should be an instance of\r\n--   <tt>Ix</tt>)</li>\r\n--   <li><tt>e</tt>: the element type of the array. Only certain element\r\n--   types are supported: see <a>Data.Array.MArray</a> for a list of\r\n--   instances.</li>\r\n--   </ul>\r\ndata IOUArray i e\r\n\r\n-- | Reads a number of <a>Word8</a>s from the specified <a>Handle</a>\r\n--   directly into an array.\r\nhGetArray :: Handle -> IOUArray Int Word8 -> Int -> IO Int\r\n\r\n-- | Writes an array of <a>Word8</a> to the specified <a>Handle</a>.\r\nhPutArray :: Handle -> IOUArray Int Word8 -> Int -> IO ()\r\n\r\n\r\n-- | An overloaded interface to mutable arrays. For array types which can\r\n--   be used with this interface, see <a>Data.Array.IO</a>,\r\n--   <a>Data.Array.ST</a>, and <a>Data.Array.Storable</a>. . Safe API only\r\n--   of <a>Data.Array.MArray</a>.\r\nmodule Data.Array.MArray.Safe\r\n\r\n-- | Class of mutable array types.\r\n--   \r\n--   An array type has the form <tt>(a i e)</tt> where <tt>a</tt> is the\r\n--   array type constructor (kind <tt>* -&gt; * -&gt; *</tt>), <tt>i</tt>\r\n--   is the index type (a member of the class <a>Ix</a>), and <tt>e</tt> is\r\n--   the element type.\r\n--   \r\n--   The <tt>MArray</tt> class is parameterised over both <tt>a</tt> and\r\n--   <tt>e</tt> (so that instances specialised to certain element types can\r\n--   be defined, in the same way as for <a>IArray</a>), and also over the\r\n--   type of the monad, <tt>m</tt>, in which the mutable array will be\r\n--   manipulated.\r\nclass (Monad m) => MArray a e m\r\n\r\n-- | Builds a new array, with every element initialised to the supplied\r\n--   value.\r\nnewArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)\r\n\r\n-- | Builds a new array, with every element initialised to an undefined\r\n--   value. In a monadic context in which operations must be deterministic\r\n--   (e.g. the ST monad), the array elements are initialised to a fixed but\r\n--   undefined value, such as zero.\r\nnewArray_ :: (MArray a e m, Ix i) => (i, i) -> m (a i e)\r\n\r\n-- | Constructs a mutable array from a list of initial elements. The list\r\n--   gives the elements of the array in ascending order beginning with the\r\n--   lowest index.\r\nnewListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)\r\n\r\n-- | Read an element from a mutable array\r\nreadArray :: (MArray a e m, Ix i) => a i e -> i -> m e\r\n\r\n-- | Write an element in a mutable array\r\nwriteArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()\r\n\r\n-- | Constructs a new array derived from the original array by applying a\r\n--   function to each of the elements.\r\nmapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)\r\n\r\n-- | Constructs a new array derived from the original array by applying a\r\n--   function to each of the indices.\r\nmapIndices :: (MArray a e m, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> m (a i e)\r\n\r\n-- | Returns the bounds of the array\r\ngetBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)\r\n\r\n-- | Return a list of all the elements of a mutable array\r\ngetElems :: (MArray a e m, Ix i) => a i e -> m [e]\r\n\r\n-- | Return a list of all the associations of a mutable array, in index\r\n--   order.\r\ngetAssocs :: (MArray a e m, Ix i) => a i e -> m [(i, e)]\r\n\r\n-- | Converts a mutable array (any instance of <a>MArray</a>) to an\r\n--   immutable array (any instance of <a>IArray</a>) by taking a complete\r\n--   copy of it.\r\nfreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)\r\n\r\n-- | Converts an immutable array (any instance of <a>IArray</a>) into a\r\n--   mutable array (any instance of <a>MArray</a>) by taking a complete\r\n--   copy of it.\r\nthaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)\r\n\r\n\r\n-- | Mutable boxed and unboxed arrays in the IO monad. . Safe API only of\r\n--   <a>Data.Array.IO</a>.\r\nmodule Data.Array.IO.Safe\r\n\r\n-- | An <a>IOArray</a> is a mutable, boxed, non-strict array in the\r\n--   <a>IO</a> monad. The type arguments are as follows:\r\n--   \r\n--   <ul>\r\n--   <li><tt>i</tt>: the index type of the array (should be an instance of\r\n--   <a>Ix</a>)</li>\r\n--   <li><tt>e</tt>: the element type of the array.</li>\r\n--   </ul>\r\ndata IOArray i e\r\n\r\n-- | Mutable, unboxed, strict arrays in the <a>IO</a> monad. The type\r\n--   arguments are as follows:\r\n--   \r\n--   <ul>\r\n--   <li><tt>i</tt>: the index type of the array (should be an instance of\r\n--   <tt>Ix</tt>)</li>\r\n--   <li><tt>e</tt>: the element type of the array. Only certain element\r\n--   types are supported: see <a>Data.Array.MArray</a> for a list of\r\n--   instances.</li>\r\n--   </ul>\r\ndata IOUArray i e\r\n\r\n-- | Reads a number of <a>Word8</a>s from the specified <a>Handle</a>\r\n--   directly into an array.\r\nhGetArray :: Handle -> IOUArray Int Word8 -> Int -> IO Int\r\n\r\n-- | Writes an array of <a>Word8</a> to the specified <a>Handle</a>.\r\nhPutArray :: Handle -> IOUArray Int Word8 -> Int -> IO ()\r\n\r\n\r\n-- | Mutable boxed and unboxed arrays in the <a>ST</a> monad.\r\nmodule Data.Array.ST\r\n\r\n-- | Mutable, boxed, non-strict arrays in the <a>ST</a> monad. The type\r\n--   arguments are as follows:\r\n--   \r\n--   <ul>\r\n--   <li><tt>s</tt>: the state variable argument for the <a>ST</a>\r\n--   type</li>\r\n--   <li><tt>i</tt>: the index type of the array (should be an instance of\r\n--   <a>Ix</a>)</li>\r\n--   <li><tt>e</tt>: the element type of the array.</li>\r\n--   </ul>\r\ndata STArray s i e\r\n\r\n-- | A safe way to create and work with a mutable array before returning an\r\n--   immutable array for later perusal. This function avoids copying the\r\n--   array before returning it - it uses <tt>unsafeFreeze</tt> internally,\r\n--   but this wrapper is a safe interface to that function.\r\nrunSTArray :: (forall s. ST s (STArray s i e)) -> Array i e\r\n\r\n-- | A mutable array with unboxed elements, that can be manipulated in the\r\n--   <a>ST</a> monad. The type arguments are as follows:\r\n--   \r\n--   <ul>\r\n--   <li><tt>s</tt>: the state variable argument for the <a>ST</a>\r\n--   type</li>\r\n--   <li><tt>i</tt>: the index type of the array (should be an instance of\r\n--   <tt>Ix</tt>)</li>\r\n--   <li><tt>e</tt>: the element type of the array. Only certain element\r\n--   types are supported.</li>\r\n--   </ul>\r\n--   \r\n--   An <a>STUArray</a> will generally be more efficient (in terms of both\r\n--   time and space) than the equivalent boxed version (<a>STArray</a>)\r\n--   with the same element type. However, <a>STUArray</a> is strict in its\r\n--   elements - so don't use <a>STUArray</a> if you require the\r\n--   non-strictness that <a>STArray</a> provides.\r\ndata STUArray s i e\r\n\r\n-- | A safe way to create and work with an unboxed mutable array before\r\n--   returning an immutable array for later perusal. This function avoids\r\n--   copying the array before returning it - it uses <tt>unsafeFreeze</tt>\r\n--   internally, but this wrapper is a safe interface to that function.\r\nrunSTUArray :: (forall s. ST s (STUArray s i e)) -> UArray i e\r\n\r\n\r\n-- | Mutable boxed and unboxed arrays in the <a>ST</a> monad.\r\n--   \r\n--   Safe API only of <a>Data.Array.ST</a>.\r\nmodule Data.Array.ST.Safe\r\n\r\n-- | Mutable, boxed, non-strict arrays in the <a>ST</a> monad. The type\r\n--   arguments are as follows:\r\n--   \r\n--   <ul>\r\n--   <li><tt>s</tt>: the state variable argument for the <a>ST</a>\r\n--   type</li>\r\n--   <li><tt>i</tt>: the index type of the array (should be an instance of\r\n--   <a>Ix</a>)</li>\r\n--   <li><tt>e</tt>: the element type of the array.</li>\r\n--   </ul>\r\ndata STArray s i e\r\n\r\n-- | A safe way to create and work with a mutable array before returning an\r\n--   immutable array for later perusal. This function avoids copying the\r\n--   array before returning it - it uses <tt>unsafeFreeze</tt> internally,\r\n--   but this wrapper is a safe interface to that function.\r\nrunSTArray :: (forall s. ST s (STArray s i e)) -> Array i e\r\n\r\n-- | A mutable array with unboxed elements, that can be manipulated in the\r\n--   <a>ST</a> monad. The type arguments are as follows:\r\n--   \r\n--   <ul>\r\n--   <li><tt>s</tt>: the state variable argument for the <a>ST</a>\r\n--   type</li>\r\n--   <li><tt>i</tt>: the index type of the array (should be an instance of\r\n--   <tt>Ix</tt>)</li>\r\n--   <li><tt>e</tt>: the element type of the array. Only certain element\r\n--   types are supported.</li>\r\n--   </ul>\r\n--   \r\n--   An <a>STUArray</a> will generally be more efficient (in terms of both\r\n--   time and space) than the equivalent boxed version (<a>STArray</a>)\r\n--   with the same element type. However, <a>STUArray</a> is strict in its\r\n--   elements - so don't use <a>STUArray</a> if you require the\r\n--   non-strictness that <a>STArray</a> provides.\r\ndata STUArray s i e\r\n\r\n-- | A safe way to create and work with an unboxed mutable array before\r\n--   returning an immutable array for later perusal. This function avoids\r\n--   copying the array before returning it - it uses <tt>unsafeFreeze</tt>\r\n--   internally, but this wrapper is a safe interface to that function.\r\nrunSTUArray :: (forall s. ST s (STUArray s i e)) -> UArray i e\r\n\r\n\r\n-- | A storable array is an IO-mutable array which stores its contents in a\r\n--   contiguous memory block living in the C heap. Elements are stored\r\n--   according to the class <tt>Storable</tt>. You can obtain the pointer\r\n--   to the array contents to manipulate elements from languages like C.\r\n--   \r\n--   It is similar to <a>IOUArray</a> but slower. Its advantage is that\r\n--   it's compatible with C.\r\nmodule Data.Array.Storable\r\n\r\n-- | The array type\r\ndata StorableArray i e\r\n\r\n-- | The pointer to the array contents is obtained by\r\n--   <a>withStorableArray</a>. The idea is similar to <a>ForeignPtr</a>\r\n--   (used internally here). The pointer should be used only during\r\n--   execution of the <a>IO</a> action retured by the function passed as\r\n--   argument to <a>withStorableArray</a>.\r\nwithStorableArray :: StorableArray i e -> (Ptr e -> IO a) -> IO a\r\n\r\n-- | If you want to use it afterwards, ensure that you\r\n--   <a>touchStorableArray</a> after the last use of the pointer, so the\r\n--   array is not freed too early.\r\ntouchStorableArray :: StorableArray i e -> IO ()\r\n\r\n\r\n-- | A storable array is an IO-mutable array which stores its contents in a\r\n--   contiguous memory block living in the C heap. Elements are stored\r\n--   according to the class <tt>Storable</tt>. You can obtain the pointer\r\n--   to the array contents to manipulate elements from languages like C.\r\n--   \r\n--   It is similar to <a>IOUArray</a> but slower. Its advantage is that\r\n--   it's compatible with C.\r\n--   \r\n--   Safe API only of <a>Data.Array.Storable</a>.\r\nmodule Data.Array.Storable.Safe\r\n\r\n-- | The array type\r\ndata StorableArray i e\r\n\r\n-- | The pointer to the array contents is obtained by\r\n--   <a>withStorableArray</a>. The idea is similar to <a>ForeignPtr</a>\r\n--   (used internally here). The pointer should be used only during\r\n--   execution of the <a>IO</a> action retured by the function passed as\r\n--   argument to <a>withStorableArray</a>.\r\nwithStorableArray :: StorableArray i e -> (Ptr e -> IO a) -> IO a\r\n\r\n-- | If you want to use it afterwards, ensure that you\r\n--   <a>touchStorableArray</a> after the last use of the pointer, so the\r\n--   array is not freed too early.\r\ntouchStorableArray :: StorableArray i e -> IO ()\r\n\r\n\r\n-- | Unboxed immutable arrays.\r\nmodule Data.Array.Unboxed\r\n\r\n-- | Arrays with unboxed elements. Instances of <a>IArray</a> are provided\r\n--   for <a>UArray</a> with certain element types (<a>Int</a>,\r\n--   <a>Float</a>, <a>Char</a>, etc.; see the <a>UArray</a> class for a\r\n--   full list).\r\n--   \r\n--   A <a>UArray</a> will generally be more efficient (in terms of both\r\n--   time and space) than the equivalent <a>Array</a> with the same element\r\n--   type. However, <a>UArray</a> is strict in its elements - so don't use\r\n--   <a>UArray</a> if you require the non-strictness that <a>Array</a>\r\n--   provides.\r\n--   \r\n--   Because the <tt>IArray</tt> interface provides operations overloaded\r\n--   on the type of the array, it should be possible to just change the\r\n--   array type being used by a program from say <tt>Array</tt> to\r\n--   <tt>UArray</tt> to get the benefits of unboxed arrays (don't forget to\r\n--   import <a>Data.Array.Unboxed</a> instead of <a>Data.Array</a>).\r\ndata UArray i e\r\n\r\n\r\n-- | Contains the various unsafe operations that can be performed on\r\n--   arrays.\r\nmodule Data.Array.Unsafe\r\n\r\n-- | Casts an <a>STUArray</a> with one element type into one with a\r\n--   different element type. All the elements of the resulting array are\r\n--   undefined (unless you know what you're doing...).\r\ncastSTUArray :: STUArray s ix a -> ST s (STUArray s ix b)\r\n\r\n-- | Casts an <a>IOUArray</a> with one element type into one with a\r\n--   different element type. All the elements of the resulting array are\r\n--   undefined (unless you know what you're doing...).\r\ncastIOUArray :: IOUArray ix a -> IO (IOUArray ix b)\r\n\r\n-- | Converts an mutable array into an immutable array. The implementation\r\n--   may either simply cast the array from one type to the other without\r\n--   copying the array, or it may take a full copy of the array.\r\n--   \r\n--   Note that because the array is possibly not copied, any subsequent\r\n--   modifications made to the mutable version of the array may be shared\r\n--   with the immutable version. It is safe to use, therefore, if the\r\n--   mutable version is never modified after the freeze operation.\r\n--   \r\n--   The non-copying implementation is supported between certain pairs of\r\n--   array types only; one constraint is that the array types must have\r\n--   identical representations. In GHC, The following pairs of array types\r\n--   have a non-copying O(1) implementation of <a>unsafeFreeze</a>. Because\r\n--   the optimised versions are enabled by specialisations, you will need\r\n--   to compile with optimisation (-O) to get them.\r\n--   \r\n--   <ul>\r\n--   <li><a>IOUArray</a> -&gt; <a>UArray</a></li>\r\n--   <li><a>STUArray</a> -&gt; <a>UArray</a></li>\r\n--   <li><a>IOArray</a> -&gt; <a>Array</a></li>\r\n--   <li><a>STArray</a> -&gt; <a>Array</a></li>\r\n--   </ul>\r\nunsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)\r\n\r\n-- | Converts an immutable array into a mutable array. The implementation\r\n--   may either simply cast the array from one type to the other without\r\n--   copying the array, or it may take a full copy of the array.\r\n--   \r\n--   Note that because the array is possibly not copied, any subsequent\r\n--   modifications made to the mutable version of the array may be shared\r\n--   with the immutable version. It is only safe to use, therefore, if the\r\n--   immutable array is never referenced again in this thread, and there is\r\n--   no possibility that it can be also referenced in another thread. If\r\n--   you use an unsafeThaw<i>write</i>unsafeFreeze sequence in a\r\n--   multi-threaded setting, then you must ensure that this sequence is\r\n--   atomic with respect to other threads, or a garbage collector crash may\r\n--   result (because the write may be writing to a frozen array).\r\n--   \r\n--   The non-copying implementation is supported between certain pairs of\r\n--   array types only; one constraint is that the array types must have\r\n--   identical representations. In GHC, The following pairs of array types\r\n--   have a non-copying O(1) implementation of <a>unsafeThaw</a>. Because\r\n--   the optimised versions are enabled by specialisations, you will need\r\n--   to compile with optimisation (-O) to get them.\r\n--   \r\n--   <ul>\r\n--   <li><a>UArray</a> -&gt; <a>IOUArray</a></li>\r\n--   <li><a>UArray</a> -&gt; <a>STUArray</a></li>\r\n--   <li><a>Array</a> -&gt; <a>IOArray</a></li>\r\n--   <li><a>Array</a> -&gt; <a>STArray</a></li>\r\n--   </ul>\r\nunsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)\r\n\r\n-- | Construct a <a>StorableArray</a> from an arbitrary <a>ForeignPtr</a>.\r\n--   It is the caller's responsibility to ensure that the <a>ForeignPtr</a>\r\n--   points to an area of memory sufficient for the specified bounds.\r\nunsafeForeignPtrToStorableArray :: Ix i => ForeignPtr e -> (i, i) -> IO (StorableArray i e)\r\n","ConspectRecords":[]}